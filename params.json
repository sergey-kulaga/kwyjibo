{
  "name": "Kwyjibo",
  "tagline": "A set of Typescript Decorators and helpers to write better node.js+Express applications.",
  "body": "#Kwyjibo\r\nA set of TypeScript Decorators and helpers for a better node.js+Express experience.\r\n\r\n##TL;DR\r\nWatch this video\r\n\r\n[![Video](http://img.youtube.com/vi/OiXc3kKcn5g/0.jpg)](http://www.youtube.com/watch?v=OiXc3kKcn5g)\r\n\r\n\r\n##Key features\r\n\r\n- [Requirements](#requirements)\r\n- [Express integration](#express-integration)\r\n- [Controllers and Actions](#controllers-and-actions)\r\n- [Custom mount conditions](#custom-mount-conditions)\r\n- [Error Handling](#error-handling)\r\n- [Tests execution and automation](#tests-execution-and-automation)\r\n- [Documentation generator](#documentation-generator)\r\n\r\n##Quickstart\r\n\r\n1. Install [Visual Studio Code](https://code.visualstudio.com/Download)\r\n2. Install `yo` with the  `generator-kwyjibo` package, and the required dependencies for every-day development (`typescript`)\r\n\r\n\t```\r\n\tnpm install --global yo generator-kwyjibo typescript@beta\r\n\t```\r\n\r\n3. Use the `generator-kwyjibo` to scaffold a new web app in the current directory. When asked, give a name to the app and answer `Yes` to every generator option\r\n\r\n\t```\r\n\tyo kwyjibo\r\n\t```\r\n\r\n4. Start Visual Studio Code\r\n\t```\r\n\tcode .\r\n\t```\r\n\r\n5. Press `F1` and type `>Run Build Task` to build the app\r\n\r\n6. Press `F5`  to start the Kwyjibo app in `http://localhost:3000`\r\n\r\n7. You did it! Your Kwyjibo app is up and running!\r\n\r\n\r\n##Requirements\r\n\r\nTo use the Kwyjibo framework with a Node.js+Express web app, the minimum requirements are:\r\n\r\n- Node.js 6.x\r\n- Express 4.14.0\r\n- TypeScript 2.0.0 (beta), with:\r\n\t- `experimentalDecorators` support \r\n\t- ECMAScript 6 target \r\n\r\n(in your `tsconfig.json` file, inside `compilerOptions` set `experimentalDecorators` to `true` and `target` to `es6`)\r\n\r\n\r\n##Express integration\r\n\r\nThe easiest way to use Kwyjibo is using the Yeoman generator, as it is explained in the [quickstart](#quickstart). However, if you already have an Express application, or just don't want to use the generator, you can use this steps to integrate Kwyjibo with an existing Express app.\r\n\r\nOnce you have an Express app up and running (and using TypeScript), go to a terminal and run `npm install --save kwyjibo` to add it as a dependency to you app. Then, open the app entrypoint (let's say, `app.ts`) and add the following line at the beginning:\r\n\r\n`import * as Kwyjibo from \"kwyjibo\"`\r\n\r\nAnd right after creating the Http server, add the following lines (assuming `expressApp` is an object containing the Express app):\r\n\r\n```typescript\r\n// Init all Kwyjibo controllers and tests (assuming \"tests\" and \"controllers\" folders)\r\n// To use custom folders, pass the folder names as extra parameters to initialize\r\nKwyjibo.initialize(App.express);\r\n```\r\n\r\nThis will configure the framework loggers, and load all the tests and controllers that are inside the `tests` and `controllers` folders\r\n\r\n\r\n##Controllers and Actions\r\n\r\nThe main components in a Kwyjibo app are the controllers and their actions.\r\nEach controller is a mount point for a set of actions, and each action can handle a request to a specific path and HTTP method.\r\n\r\n###Controllers\r\n\r\nThe controllers must be decorated with the `@Controller` decorator, specifying the mount point:\r\n\r\n- `@Controller(\"/myMountPoint\")` will mount the controller in `/myMountPoint`.\r\n- `@Controller(AnotherController, \"/myMountPoint\")` will mount the controller in the specified mount point, but using `AnotherController` as its root (for instance, this could be ended up being mounted as `/someMountPoint/myMountPoint`.\r\n\r\nYou can - optionally - add the `@DocController` decorator to add documentation and the `@Middleware` decorator to apply middlewares to all the controller actions\r\n\r\n###Actions\r\n\r\nEach action is a method in the controller with either, a `@Get`, `@Post` or `@Method` decorator to specify its route and HTTP method, or at least one of the `@DocAction` or `@ActionMiddleware` decorators, and it will use the default mount point (the method name, using the `GET` HTTP method)\r\n\r\nThe `@DocAction` the same way `@DocController` does, but for actions, and the `@ActionMiddleware` to apply middlewares to particular actions. \r\n\r\nBy default, the action methods receive at least a `context: Kwyjibo.Context` parameter that allows it to access the request and response objects and can return:\r\n\r\n- If the action just returns `200 OK`, invokes to `context.response.render` or manually handles the `context.response`:\r\n - `void` \r\n - `Promise<void>`\r\n- if the actions returns `200 OK` and sends a string as a response (for instance, an HTML):  \r\n - `string`\r\n - `Promise<string>`\r\n- If the action returns a `200 OK` and sends a `json` object as a response:  \r\n - `Object`\r\n - `Promise<Object>`\r\n\r\nIn any of those cases, if an exception is thrown (or the promise is rejected), the exception will be handled by the error handler middlewares configured in Express.\r\n\r\nAlso, a method can return an HttpError for which the correct status and message will be sent. For example:\r\n```typescript\r\nasync someMethod(context:Context): Promise<Object|HttpError> {\r\n\tlet retObj = await someMethodThatBringsTheObject();\r\n\tif(retObj == undefined) {\r\n\t\treturn NotFound(\"Cannot find the requested object\");\r\n\t}\r\n\treturn retObj;\r\n}\r\n```\r\n\r\n###Parameters\r\n\r\nTo use request parameters from the body, route path, querystring, headers or cookies, you can decorate any action parameter but the first (that must be the context) with the following decorators:\r\n\r\n- `@FromBody(\"paramName\")`\r\n- `@FromPath(\"paramName\")`\r\n- `@FromQuery(\"paramName\")`\r\n- `@FromHeader(\"paramName\")`\r\n- `@FromCookie(\"paramName\")`\r\n\r\nFor instance, to create a controller for users operations:\r\n- Create a `controllers` folder in your app root and create a `usersController.ts` file inside.\r\n- Add the following code:\r\n\r\n```typescript\r\nimport * as K from \"kwyjibo\";\r\n\r\n@K.Controller(\"/users\")\r\n@K.DocController(\"Users Controller.\")\r\n@K.Middleware(UsersController.loggingMiddleware)\r\nclass UsersController {\r\n\r\n\tstatic loggingMiddleware(req: Express.Request, res: Express.Response, next: Function) {\r\n\t\tconsole.log(\"Request to: \" + req.path);\r\n\t}\r\n\r\n    @K.Get(\"/\")\r\n    @K.DocAction(`Users index`)\r\n    index(context: K.Context): string {\r\n        return \"<html><body><ul><li>/list: all users</li><li>/user/:id: specifi user</li></ul></body></html>\";\r\n    }\r\n\r\n    @K.Get(\"/list\")\r\n    @K.DocAction(`Return all users`)\r\n    allUsers(context: Context): Object {\r\n        let users = UsersRepository.getAllUsers();\r\n        return users; // this action will send a json object\r\n    }\r\n\r\n    @Get(\"/user/:id\")\r\n    @DocAction(`Return a specific user`)\r\n    oneUser(context: Context, @FromPath(\"id\") id: string): string {\r\n        let user = UsersRepository.getUser(id);\r\n        return user;\r\n    }\r\n}\r\n```\r\n\r\n###Migration from standard Express\r\n\r\nIf you want to use the standard Express route method signature, instead of just receiving the `context` object (useful to migrate classic Express apps to Kwyjibo), you can use the `@ExpressCompatible` decorator and create methods like this:\r\n\r\n```typescript\r\n@Get(\"/somewhere)\r\n@ExpressCompatible()\r\nmyExpressCompatibleAction(req: Express.Request, res: Express.Response, next: Function): void {\r\n\t// do something\r\n}\r\n```\r\n\r\n\r\n##Custom mount conditions\r\n\r\nIf you want to mount controllers conditionally, you can use the `@MountCondition` decorator.\r\n\r\n###Dev environment\r\nWhen the node app is started with the environment variable `NODE_ENV = development`, every controller that doesn't have it's root endpoint mapped to an action will autogenerate an index with links to every action available at that endpoint.\r\n\r\nAlso, if you have controllers that should only be exposed in development environment, you can use the `@Dev` controller decorator (a special case of a custom mount condition) and it will only be mounted if that condition is met.\r\n\r\n\r\n##Error Handling\r\n\r\nKwijibo will automatically handle errors thrown inside actions and send a `500 Internal Server Error` response.\r\nHowever, you can throw known error types that Kwyjibo can handle:\r\n- `HttpError`: custom HttpError, with message and status code\r\n- `InternalServerError`: 500 error with message\r\n- `NotFound`: 404 error with message\r\n- `BadRequest`: 400 error with message\r\n- `Unauthorized`: 401 error with message\r\n\r\nFor instance, if you wanted to validate a payload in a web API, you would do something like this:\r\n\r\n```typescript\r\n@Controller(\"/api\")\r\nclass Api {\r\n\t@Get()\r\n\tdoSomething(context: Context, @FromQuery(\"id\") id: string): Object {\r\n\t\tif (id == undefined) {\r\n\t\t\tthrow new BadRequest(\"id parameter is required\");\r\n\t\t}\r\n\t\t\r\n\t\treturn {\r\n\t\t\tvalue: id\r\n\t\t};\r\n\t}\r\n}\r\n```\r\n\r\n##Tests execution and automation\r\n\r\nThe Kwyjibo framework includes the autogeneration of endpoints for integration tests execution, in both interactive and automatic scenarios.\r\n\r\n###Test fixture\r\n\r\nTo add tests to you app, create a `sampleTests.ts` file inside the `tests` folder under the app root. The test fixture class must be decorated with `@Fixture` and each test is a method inside it that has the `@Test` decorator.\r\n\r\nTo do the test preparation and cleanup, you can write methods inside the fixture with the `@Before` and `@After` decorators.\r\n\r\nEach test method can have either `void` or `Promise<void>`as its return type.\r\n\r\nIf the test finishes its execution successfully, will be considered as passed. To make a test fail, it must throw an exeption, or reject the returned promise.\r\n\r\nA Test fixture example:\r\n\r\n```typescript\r\nimport * as K from \"kwyjibo\"\r\n\r\n@K.Fixture()\r\nexport default class Fixture {\r\n    @K.Before()\r\n    prepare(): void {\r\n        // this method will run before the tests\r\n    }\r\n\r\n    @K.Test(\"A test that passes\")\r\n    test1(): void {\r\n        // this test will pass\r\n    }\r\n\r\n    @K.Test(\"A test that fails\")\r\n    test2(): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n\t        reject(new Error('failed test!'));\r\n        });\r\n    }\r\n\r\n    @K.After()\r\n    cleanUp(): void {\r\n        // this method will run after the tests\r\n    }\r\n}\r\n```\r\n\r\n###Test runner\r\n\r\nThen, you have to add the `@TestRunner` decorator to a controller. It will scan for all the available test fixtures in the app and generate the endpoints to execute them.\r\n\r\nA controller with the autogenerated test endpoints (test runner):\r\n\r\n```typescript\r\nimport * as K from \"kwyjibo\";\r\n\r\n@K.TestRunner()\r\n@K.Controller(\"/test\")\r\nexport default class Test {\r\n}\r\n```\r\n\r\nThe interactive test runner will explain how to invoke the same set of tests programatically. \r\n\r\n\r\n##Documentation generator\r\n\r\nKwyjibo reads all the `@DocController` and `@DocAction` decorators and uses that information to automatically generate documentation for your web app or API\r\n\r\nThere are two functions available to access obtain the generated documentation:\r\n- `Kwyjibo.getDocs()`: returns a `ControllerDocNode[]` representing all the controllers documentation with their actions.\r\n- `Kwyjibo.getDocsAsHTML()`: returns a string with the controllers documentation as HTML\r\n\r\nFor instance, if you wanted to have a documentation endpoint for your web API, and it should only be exposed when running in a dev environment, you should create the following controller:\r\n\r\n```typescript\r\nimport * as K from \"kwyjibo\";\r\n\r\nK.Dev()\r\nK.Controller(\"/docs\")\r\nK.DocController(\"API Documentation\")\r\nexport default class DocsController {\r\n\t@K.Get(\"/\")\r\n\thtmlDocs(context: K.Context): string {\r\n\t\treturn K.getDocsAsHTML();\r\n\t}\r\n}\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}